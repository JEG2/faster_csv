= To Do List

The following is a list of planned expansions for FasterCSV, in no particular
order.

* Find a good headers solution for data like this:
    "Experiment ID:	1",,,,,,,,,,,,
    "Subject ID:	1013938829432171e868c340.
    Trial,stimulus,time,type,field1,field2,text_response,Abs. time of
    response,,,,,
    26,undefined,14828,KEY,RETURN,UNUSED,DCS,Sat Oct 15 17:48:04 GMT-0400
    2005,,,,,
    23,undefined,15078,KEY,RETURN,UNUSED,244,Sat Oct 15 17:48:19 GMT-0400
    2005,,,,,
    7,nixontrialleft copy.pct [TAG: 1],5953,KEY,1,UNUSED,,Sat Oct 15
    17:49:24 GMT-0400 2005,,,,,
    8,nixontrialfront copy.pct [TAG: 3],6250,KEY,3,UNUSED,,Sat Oct 15
    17:49:31 GMT-0400 2005,,,,,
    9,nixontrialright copy.pct [TAG: 2],2469,KEY,2,UNUSED,,Sat Oct 15
    17:49:34 GMT-0400 2005,,,,,
    #####
    more data
    ######
    ,,,,,,,,,,4374.347222,,
    ,,,,,,,,,,,,1.00
    ,,,,,,,,,,,,0.93
    ### and a new block starts
    "Experiment ID:	3",,,,,,,,,,,,0.92
    ....
* Add calculated fields.
* Improve test speed.
* Document test procedure.
* Fix Date::parse() test errors on Windows.
* It might be nice if "Unclosed Quote Error" dumped you a line number.  If it
  is possible...
* We've run into a requirement to be able to access the original row of a
  csv file, before it's been parsed. This allows us to give back to the
  user their original data rows, for any rows that we're unable to process
  properly.

  Our implementation (see below) requires re-writing #shift, which feels
  _very_ fragile since that's the primary read method.

  Can you suggest an alternative approach? Or consider providing this type
  of functionality as part of FasterCSV?

  Thanks,
  Michael



  # Added original_row accessor to FasterCSV::Row to hold content
  # if use_headers header and converters are set.
  #
  # Need to be able to return the old values back to the user in an error file.
  #
  class FasterCSV

    class Row
      # An array of data before converts change the data
      attr_accessor :original_row
    end

    #
    # The primary read method for wrapped Strings and IOs, a single row is pulled
    # from the data source, parsed and returned as an Array of fields (if header
    # rows are not used) or a FasterCSV::Row (when header rows are used).
    #
    # The data source must be open for reading.
    #
    def shift
      # begin with a blank line, so we can always add to it
      line = ""

      # 
      # it can take multiple calls to <tt>@io.gets()</tt> to get a full line,
      # because of \r and/or \n characters embedded in quoted fields
      # 
      loop do
        # add another read to the line
        line  += @io.gets(@row_sep) rescue return nil
        # copy the line so we can chop it up in parsing
        parse = line.dup
        parse.sub!(@parsers[:line_end], "")

        # 
        # I believe a blank line should be an <tt>Array.new</tt>, not 
        # CSV's <tt>[nil]</tt>
        # 
        return Array.new if parse.empty?

        # 
        # shave leading empty fields if needed, because the main parser chokes 
        # on these
        # 
        csv = if parse.sub!(@parsers[:leading_fields], "")
          [nil] * $&.length
        else
          Array.new
        end
        # 
        # then parse the main fields with a hyper-tuned Regexp from 
        # Mastering Regular Expressions, Second Edition
        # 
        parse.gsub!(@parsers[:csv_row]) do
          csv << if $1.nil?     # we found an unquoted field
            if $2.empty?        # switch empty unquoted fields to +nil+...
              nil               # for CSV compatibility
            else
              # I decided to take a strict approach to CSV parsing...
              if $2.count("\r\n").zero?  # verify correctness of field...
                $2
              else
                # or throw an Exception
                raise MalformedCSVError, 'Unquoted fields do not allow \r or \n.'
              end
            end
          else                  # we found a quoted field...
            $1.gsub('""', '"')  # unescape contents
          end
          ""  # gsub!'s replacement, clear the field
        end

        # if parse is empty?(), we found all the fields on the line...
        if parse.empty?
          # ADDED: save csv values before converts change them.
          current_row = csv.dup if @use_headers

          # convert fields if needed...
          csv = convert_fields(csv) unless header_row? or @converters.empty?
          # parse out header rows and handle FasterCSV::Row conversions...
          csv = parse_headers(csv) if @use_headers

          # ADDED: assign original_row
          csv.original_row = current_row if @use_headers and !@converters.empty?

          # return the results
          break csv
        end
        # if we're not empty?() but at eof?(), a quoted field wasn't closed...
        raise MalformedCSVError, "Unclosed quoted field." if @io.eof?
        # otherwise, we need to loop and pull some more data to complete the row
      end
    end
  end
