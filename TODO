= To Do List

The following is a list of planned expansions for FasterCSV, in no particular
order.

* Find a good headers solution for data like this:
    "Experiment ID:	1",,,,,,,,,,,,
    "Subject ID:	1013938829432171e868c340.
    Trial,stimulus,time,type,field1,field2,text_response,Abs. time of
    response,,,,,
    26,undefined,14828,KEY,RETURN,UNUSED,DCS,Sat Oct 15 17:48:04 GMT-0400
    2005,,,,,
    23,undefined,15078,KEY,RETURN,UNUSED,244,Sat Oct 15 17:48:19 GMT-0400
    2005,,,,,
    7,nixontrialleft copy.pct [TAG: 1],5953,KEY,1,UNUSED,,Sat Oct 15
    17:49:24 GMT-0400 2005,,,,,
    8,nixontrialfront copy.pct [TAG: 3],6250,KEY,3,UNUSED,,Sat Oct 15
    17:49:31 GMT-0400 2005,,,,,
    9,nixontrialright copy.pct [TAG: 2],2469,KEY,2,UNUSED,,Sat Oct 15
    17:49:34 GMT-0400 2005,,,,,
    #####
    more data
    ######
    ,,,,,,,,,,4374.347222,,
    ,,,,,,,,,,,,1.00
    ,,,,,,,,,,,,0.93
    ### and a new block starts
    "Experiment ID:	3",,,,,,,,,,,,0.92
    ....
* Add calculated fields.
* Examples, examples, examples...
* Ara's suggestion:


  play with this, let me know what you think, it's pretty nice to use:
  
  
  
  harp:~ > cat a.rb
  require 'pathname'
  
  require 'rubygems'
  require 'fastercsv' # gem install fastercsv require 'arrayfields' # gem install arrayfields
  
  class FasterCSV
    class Table < ::Array
      def getopts opts
        lambda do |k, *a|
          default = a.shift
          break(opts[k]) if opts.has_key? k
          k = k.to_s
          break(opts[k]) if opts.has_key? k
          k = k.intern
          break(opts[k]) if opts.has_key? k
          default
        end
      end
  
      ATTRIBUTES = %w(
        fields
        no_header
        pathname
      )
  
      ATTRIBUTES.each{|a| attr a}
  
      def initialize a, opts = {}, &b
        super()
  
        o = getopts opts
  
        @fields = o[:fields]
        @no_header = o[:no_header]
        @pathname = nil
  
        t =
          case a
            when Array
              a
            when Pathname
              @pathname = a
              FasterCSV.read @pathname
            else
              FasterCSV.parse a.to_s
          end
  
        two_d = (
          t.is_a?(Array) and
          t.first.is_a?(Array) and
          not two_d = t.first.first.is_a?(Array)
        )
  
        raise ArgumentError, a.class unless two_d
  
        replace t
  
        @fields = shift unless @fields or @no_header
  
        @fields.map{|f| f.to_s}
  
        each{|row| row.fields = @fields}
      end
  
      def [] i
        begin
          super
        rescue IndexError, TypeError, ArgumentError
          map{|row| row[i]}
        end
      end
  
      alias_method "column", "[]"
      alias_method "col", "[]"
  
      def []= i, v
        begin
          super
        rescue IndexError, TypeError, ArgumentError
          map{|row| row[i] = v}
        end
      end
  
      def self.parse s
        new s.to_s
      end
  
      def self.read pn
        pn = Pathname.new pn.to_s
        new pn
      end
  
      def self.table t
        new t.to_a
      end
    end
  
    def self.Table(*a, &b) Table.new(*a, &b) end
    def self.table(*a, &b) Table.new(*a, &b) end
  end
  
  
  if $0 == __FILE__
  #
  # util
  #
    require 'tempfile'
  
    def data
      [
        %w( first  last ssn age ),
        %w( john   doe  123 16  ),
        %w( mary   key  331 61  ),
        %w( zaphod b    666 42  ),
      ]
    end
  
    def genfile d = data()
      t = Tempfile.new Process.pid.to_s
      data.each{|row| t.puts row.join(',')}
      t.close
      pn = Pathname.new t.path
    end
  
  #
  # example 1 - column and row access
  #
    f = genfile
    table = FasterCSV.table f
    p table['first']          #=> ["john", "mary", "zaphod"]
    p table['ssn']            #=> ["123", "331", "666"]
    p table[0][0]             #=> "john"
    p table[0]['first']       #=> "john"
    p table[2]['age']         #=> "42"
  
    table.each{|row| p row[:ssn]} #=> "123", "321", "666"
  
  #
  # example 2 - setting an entire column
  #
    table = FasterCSV.table data
    table['first'] = 'first_name'
    p table['first'] #=> ["first_name", "first_name", "first_name"]
    p table #=> [["first_name", "doe", "123", "16"], ["first_name", "key", "331", "61"], ["first_name", "b", "666", "42"]]
  
  end
  
  
  
  
  harp:~ > ruby a.rb
  ["john", "mary", "zaphod"]
  ["123", "331", "666"]
  "john"
  "john"
  "42"
  "123"
  "331"
  "666"
  ["first_name", "first_name", "first_name"]
  [["first_name", "doe", "123", "16"], ["first_name", "key", "331", "61"],
  ["first_name", "b", "666", "42"]]


  On Thu, 24 Aug 2006, James Edward Gray II wrote:

  Just wanted to let you know that I have seen this.  I'm under the gun on a
  deadline right now, so give me a couple of weeks to get past that.

  sounds good.

  Still, with just the briefest of glances I dig it.  I really love being able
  to grab entire columns.  I'm definitely going to work it into FasterCSV in
  some form.  (I'm considering just having FasterCSV::read/readlines return
  the table object.)

  cool.  this is my favourite part:

      harp:~ > cat a.rb
      require 'fastercsv_table.rb'

      fcsv = FasterCSV

      doc = <<-csv
      first_name,last_name,age
      zaphod,beeblebrox,42
      ara,howard,34
      csv

      t = fcsv.table.parse doc
      t.display
      p t.fields

      puts

      t['ssn'] = %w( 123 321 )
      t.display
      p t.fields

      puts

      p t.last['ssn']


      harp:~ > ruby a.rb
      zaphod,beeblebrox,42
      ara,howard,34
      ["first_name", "last_name", "age"]

      zaphod,beeblebrox,42,123
      ara,howard,34,321
      ["first_name", "last_name", "age", "ssn"]

      "321"

  so adding a column results in the column being updated along with the fields.
  this is actually automatic since arrayfields shares the @fields object.

  latest version attached/inlined below.


  require 'pathname'
  
  require 'rubygems'
  require 'fastercsv' # gem install fastercsv 
  require 'arrayfields' # gem install arrayfields
  
  class FasterCSV
    class Table < ::Array
      def getopts opts
        lambda do |k, *a|
          default = a.shift
          break(opts[k]) if opts.has_key? k
          k = k.to_s
          break(opts[k]) if opts.has_key? k
          k = k.intern
          break(opts[k]) if opts.has_key? k
          default
        end
      end
  
      ATTRIBUTES = %w( 
        fields
        no_header
        pathname
      )
  
      ATTRIBUTES.each{|a| attr a}
  
      def initialize a, opts = {}, &b
        super()
  
        o = getopts opts
  
        @fields = o[:fields]
        @no_header = o[:no_header]
        @pathname = nil
  
        t =
          case a
            when Array
              a
            when Pathname
              @pathname = a
              FasterCSV.read @pathname 
            else
              FasterCSV.parse a.to_s
          end
  
        two_d = (
          t.is_a?(Array) and 
          t.first.is_a?(Array) and 
          not two_d = t.first.first.is_a?(Array)
        )
  
        raise ArgumentError, a.class unless two_d
  
        replace t
  
        @fields = shift unless @fields or @no_header
  
        @fields.map{|f| f.to_s}
  
        each{|row| row.fields = @fields}
      end
  
      def [] i
        begin
          super
        rescue IndexError, TypeError, ArgumentError
          map{|row| row[i]}
        end
      end
      alias_method "column", "[]"
      alias_method "col", "[]"
  
      def []= i, v
        begin
          super
        rescue IndexError, TypeError, ArgumentError
          v = shiftable v
          map{|row| row[i] = v.shift}
        end
      end
  
      def shiftable v 
        v.respond_to?('shift') ? v : Class.new{define_method('shift'){v}}.new
      end
  
      def to_csv port=''
        FasterCSV(port){|port| each{|row| port << row}}
      end
  
      def display
        to_csv STDOUT
      end
  
      def self.parse s
        new s.to_s
      end
  
      def self.read pn
        pn = Pathname.new pn.to_s
        new pn
      end
  
      def self.table t
        new t.to_a
      end
    end
    
    def self.Table(*a, &b) (a.empty? and b.nil?) ? Table : Table.new(*a, &b) end
    def self.table(*a, &b) (a.empty? and b.nil?) ? Table : Table.new(*a, &b) end
  end
  
  
  if $0 == __FILE__
  #
  # util
  #
    require 'tempfile'
  
    def data 
      [
        %w( first  last ssn age ), 
        %w( john   doe  123 16  ), 
        %w( mary   key  331 61  ), 
        %w( zaphod b    666 42  ), 
      ]
    end
  
    def genfile d = data()
      t = Tempfile.new Process.pid.to_s
      data.each{|row| t.puts row.join(',')}
      t.close
      pn = Pathname.new t.path
    end
  
  #
  # example 1 - column and row access
  #
    f = genfile
    table = FasterCSV.table f 
    p table['first']          #=> ["john", "mary", "zaphod"] 
    p table['ssn']            #=> ["123", "331", "666"]
    p table[0][0]             #=> "john"
    p table[0]['first']       #=> "john"
    p table[2]['age']         #=> "42" 
  
    table.each{|row| p row[:ssn]} #=> "123", "321", "666"
  
  #
  # example 2 - setting an entire column
  #
    table = FasterCSV.table data 
    table['first'] = 'first_name'
    p table['first'] #=> ["first_name", "first_name", "first_name"]
    p table #=> [["first_name", "doe", "123", "16"], ["first_name", "key", "331", "61"], ["first_name", "b", "666", "42"]]
  
  end
